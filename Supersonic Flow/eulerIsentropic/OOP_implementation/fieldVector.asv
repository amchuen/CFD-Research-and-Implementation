classdef fieldVector
    
    properties
        % setup
        gr % grid
        fv % field value
        bc % boundary conditions
        ct % control variables

        % gradient derivs
        f_1f % gradient in row direction (1), forward (f)
        f_1b % gradient in row direction (1), backward (b)
        f_1 % central difference gradient

        f_2f
        f_2b
        f_2

        % laplacian
        f_11 % 2nd deriv in row direction
        f_22 % 2nd deriv in column direction
        laplace
        
    end
    
    methods % initialization and calculus-based operations
        function obj = fieldVector(gr, bc, ct, time_axis, init_fv)
           obj.gr = gr;
           obj.bc = bc;
           obj.ct = ct;
           
           fv = [];
           for i = 1:length(init_fv)
              fv = cat(3, fv, init_fv{i});
           end
           
           if time_axis
               obj.fv = repmat(fv, 1, 1, 1, 3);...(-(1 + (r_cyl^2)./(obj.GR.d11.^2)).*sin(obj.GR.d22))), 1, 1, 1, 3); % rho * v
           else
               obj.fv = fv;                            
           end
           
           obj = obj.Gradient();
           obj = obj.Laplacian();           

        end
        
        function obj = Laplacian(obj)
            % Get f_11 and f_22
            if obj.ct.is_polar
                % deriv 1 is radial direction
                rr_n = [0.5.*(obj.gr.d11(2:end,:) + obj.gr.d11(1:(end-1),:)); 0.5.*((obj.gr.d11(end,:)+dr) + obj.gr.d11(end,:))];
                rr_s = 0.5.*([2.*obj.gr.d11(1,:); obj.gr.d11(2:end,:) + obj.gr.d11(1:(end-1),:)]);
                obj.f_11 = (rr_n.*obj.f_1f - rr_s.*obj.f_1b)./(obj.gr.d1.*obj.gr.d11);

                % deriv 2 is in angular direction
                obj.f_22 = (obj.f_2f - obj.f_2b)./(obj.gr.d2.*obj.gr.d11);

            else
                % deriv 1 is in y direction
                obj.f_11 = (obj.f_1f - obj.f_1b)./obj.gr.d1;

                % deriv 2 is in x direction
                obj.f_22 = (obj.f_2f - obj.f_2b)./obj.gr.d2;
            end

            % Get Full Laplacian
            obj.laplace= obj.f_11 + obj.f_22;

        end
        
        function obj = Gradient(obj) % maybe should create a vector instead?
            % Solution
            if length(size(obj.fv)) == 4
                % means vector does not have time dimension
                % third dimension is not related to domain, but rather
                % storage for variables
                FF = obj.fv(:,:,:,2);
            else
                % means variable does not have time aspect
                FF = obj.fv;
            end
            
            % Initialize Variables
            obj.f_1f = zeros(size(FF));
            obj.f_1b = obj.f_1f;
            obj.f_1 = obj.f_1f;
            obj.f_2f = obj.f_1f;
            obj.f_2b = obj.f_1f;
            obj.f_2 = obj.f_1f;

            % Calculate forward and backward 1st-order differences
            obj.f_1f(1:(end-1),:,:) = (diff(FF,1,1)./obj.gr.d1);
            obj.f_1b(2:end,:,:) = diff(FF,1,1)./obj.gr.d1;
            if obj.ct.is_polar
                obj.f_2f(:,1:(end-1),:) = (diff(FF,1,2)./(obj.gr.d2 .* obj.gr.RR(:,1:(end-1))));
                obj.f_2b(:,2:end,:) = diff(FF,1,2)./(obj.gr.d2 .* obj.gr.RR(:,2:end));
            else
                obj.f_2f(:,1:(end-1),:) = (diff(FF,1,2)./obj.gr.d2);
                obj.f_2b(:,2:end,:) = diff(FF,1,2)./obj.gr.d2;
            end

            % Loop through boundary conditions and apply
            fnames = fieldnames(obj.bc);
            for i = 1:length(fnames) % loop through directions
                % generate temporary array of values from
                % scalars or vectors                
                BC_vals = obj.getBCvals(FF, dir);
                
                % assign the boundary conditions to the corresponding
                % gradient matrices
                switch fnames{i}
                    case 'W'
                        obj.f_2b(:,1,:) = BC_vals;
                    case 'E'
                        obj.f_2f(:,end,:) = BC_vals;
                    case 'S'
                        obj.f_1b(1,:,:) = BC_vals;
                    case 'N'
                        obj.f_1f(end,:,:) = BC_vals;
                end
            end

            % Calculate Central Difference
            obj.f_1 = 0.5.*(obj.f_1f + obj.f_1b);
            obj.f_2 = 0.5.*(obj.f_2f + obj.f_2b);


        end
        
    end
    
    methods % three-level-scheme related operations
        
        function obj = update_fv(obj, updateVals)
        % this function updates the field values for the fieldVector
            if ((nargin == 1) && (length(size(obj.fv)) == 4))
               % vector has time dimension in it, and only needs to step
               % forward in time
               obj.fv(:,:,:,1:2) = obj.fv(:,:,:,2:3);
            elseif ((nargin == 2))
                % updated values must be passed into the new vector
                for i = 1:length(updateVals)
                   obj.fv(:,:,i) = updateVals{i}; 
                end 
            
            else
                error('Three-level scheme implementation error!\n Fix implementation or create a new update case.\n');
            end            
        end
        
        function obj = update_bc(obj, dir, updateVals)
           % need to somehow access boundary conditions easily at relevant
           % locations based on wall and etc.
           
            for ii = 1:length(updateVals)
                if ~isempty(updateVals{ii})
                    obj.bc.(dir).val{ii} = updateVals{ii};
                end
            end
            
        end
    end
    
    methods % getter functions
        function output = get_boundVal(obj, dir, varargin)
            % INPUTS: 
                % varargin - 1st input is time index
                %           2nd input is the element index
            
            % Parse variable inputs for time and element indexing
            % information
            t_dim = [];
            elem = [];
            if ~isempty(varargin)
                if ~isempty(varargin{1})
                    t_dim = varargin{1};
                end
                if length(varargin) >= 2
                    elem = varargin{2};
                end
            end
            
            % If time is still empty, select default time
            if isempty(t_dim)
                switch length(size(obj.fv))
                    case 4
                        t_dim = 2;
                    case 3
                        t_dim = 1;
                end
            end
            
            % Perform boundary value extraction
            switch dir
               case 'W'
                   output = obj.fv(:,1,:,t_dim);
               case 'E'
                   output = obj.fv(:,end,:,t_dim);
               case 'S'
                   output = obj.fv(1,:,:,t_dim);
               case 'N'
                   output = obj.fv(end,:,:,t_dim);
            end
            
            % Select element if specified
            if ~isempty(elem)
                output = output(:,:,elem);
            end
        end
        
        function output = get_boundCondVal(obj, dir, varargin)
            % OUTPUT: this function outputs the bc values for the given
            % direction
            output = obj.bc.(dir).val;
            
            if ~isempty(varargin)
                output = output{varargin{1}};
            end
            
        end
        
    end
    
    methods % helper functions for calculating the gradients
        
        function BC_vals = getBCvals(obj, FF, dir)
            
            % Setup output to proper size
            if strcmpi(dir, 'W') || strcmpi(dir, 'E')
                node_pts = obj.GR.d11(:,1);
            elseif strcmpi(dir, 'S') || strcmpi(dir, 'N')
                node_pts = obj.GR.d22(1,:);
            end
            BC_vals = zeros([size(node_pts),3]);
            
            
            for i = 1:length(obj.bc.(dir)) % loop through each subrange
                
                % Extract the corresponding field values
                if ~isempty(obj.bc.(dir)(i).ranges)
                    min_val = ;
                    max_val = obj.bc.(dir)(i).ranges(2);
                    dim_idx = (node_pts > obj.bc.(dir)(i).ranges(1)) & (node_pts < max_val);
                    if strcmpi(dir, 'W') || strcmpi(dir, 'E')
                        FF_sub = FF(dim_idx,:,:);
                    elseif strcmpi(dir, 'S') || strcmpi(dir, 'N')
                        FF_sub = FF(:,dim_idx,:);
                    end
                elseif isempty(obj.BC.(dir)(i).ranges) || (length(obj.bc.(dir)) == 1)
                    FF_sub = FF;
                    dim_idx = ones(size(node_pts));
                else
                    error('Ranges not specified!\n');
                end
                
                if strcmp(obj.bc.(dir)(i).physical, 'sym')
                    BC_temp = obj.gen_symBC(FF_sub, dir, obj.bc.(dir)(i).numerical);

                elseif strcmp(obj.bc.(dir)(i).physical, 'wall')
                    BC_temp = obj.gen_wallBC(FF_sub, dir, obj.bc.(dir)(i).numerical, obj.bc.(dir)(i).val);

                else
                    BC_temp = obj.gen_regBC(FF_sub, dir, obj.bc.(dir)(i).numerical, obj.bc.(dir)(i).val);
                end     
                
                if strcmpi(dir, 'W') || strcmpi(dir, 'E')
                    BC_vals(dim_idx,:,:) = BC_temp;
                elseif strcmpi(dir, 'S') || strcmpi(dir, 'N')
                    BC_vals(:,dim_idx,:) = BC_temp;
                end
            end            
        end
        
        function BC_vals = gen_symBC(obj, FF, dir, num_types)
            BC_vals = [];
            for ii = 1:size(FF,3) % loop through vector "elements"
                % symmetry will likely appear right on the
                % boundary of the grid... maybe need to
                % account for displaced symmetry?? 
                switch dir
                    case 'W'
                        if strcmp(num_types{ii}, 'N')
                            BC_vals = cat(3, BC_vals, (FF(:,1,ii) - FF(:,2,ii))./obj.gr.d2);
                        elseif strcmp(num_types{ii}, 'D')
                            BC_vals = cat(3, BC_vals, (FF(:,1,ii) + FF(:,2,ii))./obj.gr.d2);
                        end 

                    case 'E'
                        if strcmp(num_types{ii}, 'N')
                            BC_vals = cat(3, BC_vals, (FF(:,end-1,ii) - FF(:,end,ii))./obj.gr.d2);
                        elseif strcmp(num_types{ii}, 'D')
                            BC_vals = cat(3, BC_vals, (-FF(:,end-1,ii) - FF(:,end,ii))./obj.gr.d2);
                        end

                    case 'N'
                        if strcmp(num_types{ii}, 'N')
                            BC_vals = cat(3, BC_vals, (FF(end-1,:,ii) - FF(end,:,ii))./obj.gr.d1);
                        elseif strcmp(num_types{ii}, 'D')
                            BC_vals = cat(3, BC_vals, (-FF(end-1,:,ii) - FF(end,:,ii))./obj.gr.d1);
                        end

                    case 'S'
                        if strcmp(num_types{ii}, 'N')
                            BC_vals = cat(3, BC_vals, (FF(1,:,ii) - FF(2,:,ii))./obj.gr.d1);
                        elseif strcmp(num_types{ii}, 'D')
                            BC_vals = cat(3, BC_vals, (FF(1,:,ii) + FF(2,:,ii))./obj.gr.d1);
                        end 
                end

            end
            
        end
        
        function BC_vals = gen_regBC(obj, FF, dir, num_types, vals)
            BC_vals = [];
            for ii = 1:size(obj.fv, 3)
                switch dir
                    case 'W'
                        if isscalar(vals{ii})
                            temp_BC = vals{ii}.*ones(size(FF,1),1);
                        else
                            temp_BC = vals{ii};
                        end
                        
                        % calculate boundary deriv
                        if strcmp(num_types{ii}, 'N')
                            f_BC = FF(:,2,ii) - temp_BC.*2.*obj.gr.d2;
                            BC_vals = cat(3, BC_vals, (FF(:,1,ii) - f_BC)./obj.gr.d2);

                        elseif strcmp(num_types{ii}, 'D')
                            BC_vals = cat(3, BC_vals, (FF(:,1,ii) - temp_BC)./obj.gr.d2);

                        end 

                    case 'E'
                        if isscalar(vals{ii})
                            temp_BC = vals{ii}.*ones(size(FF,1),1);
                        else
                            temp_BC = vals{ii};
                        end
                        
                        % calculate boundary deriv
                        if strcmp(num_types{ii}, 'N')
                            f_BC = temp_BC.*2.*obj.gr.d2 + FF(:,end-1,ii);
                            BC_vals = cat(3, BC_vals, (f_BC - FF(:,end,ii))./obj.gr.d2);

                        elseif strcmp(num_types{ii}, 'D')
                            BC_vals = cat(3, BC_vals, (temp_BC - FF(:,end,ii))./obj.gr.d2);

                        end 
                        
                    case 'N'
                        if isscalar(vals{ii})
                            temp_BC = vals{ii}.*ones(1, size(FF,2));
                        else
                            temp_BC = vals{ii};
                        end
                        
                        % calculate boundary deriv
                        if strcmp(num_types{ii}, 'N')
                            f_BC = temp_BC.*2.*obj.gr.d2 + FF(end-1,:,ii);
                            BC_vals = cat(3, BC_vals, (f_BC - FF(end,:,ii))./obj.gr.d1);

                        elseif strcmp(num_types{ii}, 'D')
                            BC_vals = cat(3, BC_vals, (temp_BC - FF(end,:,ii))./obj.gr.d1);

                        end 
                        
                    case 'S'
                        if isscalar(vals{ii})
                            temp_BC = vals{ii}.*ones(1, size(FF,2));
                        else
                            temp_BC = vals{ii};
                        end
                        
                        % calculate boundary deriv
                        if strcmp(num_types{ii}, 'N')
                            f_BC = FF(2,:,ii) - temp_BC.*2.*obj.gr.d1;
                            BC_vals = cat(3, BC_vals, (FF(1,:,ii) - f_BC)./obj.gr.d1);

                        elseif strcmp(num_types{ii}, 'D')
                            BC_vals = cat(3, BC_vals, (FF(1,:,ii) - temp_BC)./obj.gr.d1);

                        end 
                        
                end
           end
        end
        
        function BC_vals = gen_wallBC(obj, FF, dir, num_types, vals)
            BC_vals = [];
            for ii = 1:size(obj.fv, 3)
                switch dir
                    case 'W'
                        if isscalar(vals{ii})
                            temp_BC = vals{ii}.*ones(size(FF,1),1);
                        else
                            temp_BC = vals{ii};
                        end
                        
                        % calculate boundary deriv
                        if strcmp(num_types{ii}, 'N')
                            BC_vals = cat(3, BC_vals, temp_BC);

                        elseif strcmp(num_types{ii}, 'D')
                            BC_vals = cat(3, BC_vals, (FF(:,1,ii) - temp_BC)./(0.5.*obj.gr.d2));

                        end 

                    case 'E'
                        if isscalar(vals{ii})
                            temp_BC = vals{ii}.*ones(size(FF,1),1);
                        else
                            temp_BC = vals{ii};
                        end
                        
                        % calculate boundary deriv
                        if strcmp(num_types{ii}, 'N')
                            BC_vals = cat(3, BC_vals, temp_BC);

                        elseif strcmp(num_types{ii}, 'D')
                            BC_vals = cat(3, BC_vals, (temp_BC - FF(:,end,ii))./(0.5.*obj.gr.d2));

                        end 
                        
                    case 'N'
                        if isscalar(vals{ii})
                            temp_BC = vals{ii}.*ones(1, size(FF,2));
                        else
                            temp_BC = vals{ii};
                        end
                        
                        % calculate boundary deriv
                        if strcmp(num_types{ii}, 'N')
                            BC_vals = cat(3, BC_vals, temp_BC);

                        elseif strcmp(num_types{ii}, 'D')
                            BC_vals = cat(3, BC_vals, (temp_BC - FF(end,:,ii))./(0.5.*obj.gr.d1));

                        end 
                        
                    case 'S'
                        if isscalar(vals{ii})
                            temp_BC = vals{ii}.*ones(1, size(FF,2));
                        else
                            temp_BC = vals{ii};
                        end
                        
                        % calculate boundary deriv
                        if strcmp(num_types{ii}, 'N')
                            BC_vals = cat(3, BC_vals, temp_BC); % need to switch order, or else derivs come out wrong!

                        elseif strcmp(num_types{ii}, 'D')
                            BC_vals = cat(3, BC_vals, (FF(1,:,ii) - temp_BC)./(0.5.*obj.gr.d1));

                        end 
                        
                end
            end
        end
    end
    
    
end